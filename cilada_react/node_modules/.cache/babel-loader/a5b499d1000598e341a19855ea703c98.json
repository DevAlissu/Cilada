{"ast":null,"code":"// src/index.tsx\nimport * as React from \"react\";\nimport { useContext, useState, useRef, useEffect } from \"react\";\nimport { useMemoOne, useOnce, raf } from \"@react-spring/shared\";\nimport { a, Controller, config as configs } from \"@react-spring/web\";\nvar ParentContext = React.createContext(null);\nfunction getScrollType(horizontal) {\n  return horizontal ? \"scrollLeft\" : \"scrollTop\";\n}\nfunction mapChildrenRecursive(children, callback) {\n  const isReactFragment = node => {\n    if (node.type) {\n      return node.type === React.Fragment;\n    }\n    return node === React.Fragment;\n  };\n  return React.Children.map(children, child => isReactFragment(child) ? mapChildrenRecursive(child.props.children, callback) : callback(child));\n}\nvar START_TRANSLATE_3D = \"translate3d(0px,0px,0px)\";\nvar START_TRANSLATE = \"translate(0px,0px)\";\nvar ParallaxLayer = React.memo(React.forwardRef(({\n  horizontal,\n  factor = 1,\n  offset = 0,\n  speed = 0,\n  sticky,\n  ...rest\n}, ref) => {\n  const parent = useContext(ParentContext);\n  const ctrl = useMemoOne(() => {\n    let translate;\n    if (sticky) {\n      const start = sticky.start || 0;\n      translate = start * parent.space;\n    } else {\n      const targetScroll = Math.floor(offset) * parent.space;\n      const distance = parent.space * offset + targetScroll * speed;\n      translate = -(parent.current * speed) + distance;\n    }\n    return new Controller({\n      space: sticky ? parent.space : parent.space * factor,\n      translate\n    });\n  }, []);\n  const layer = useMemoOne(() => ({\n    horizontal: horizontal === void 0 || sticky ? parent.horizontal : horizontal,\n    sticky: void 0,\n    isSticky: false,\n    setPosition(height, scrollTop, immediate = false) {\n      if (sticky) {\n        setSticky(height, scrollTop);\n      } else {\n        const targetScroll = Math.floor(offset) * height;\n        const distance = height * offset + targetScroll * speed;\n        ctrl.start({\n          translate: -(scrollTop * speed) + distance,\n          config: parent.config,\n          immediate\n        });\n      }\n    },\n    setHeight(height, immediate = false) {\n      ctrl.start({\n        space: sticky ? height : height * factor,\n        config: parent.config,\n        immediate\n      });\n    }\n  }), []);\n  useOnce(() => {\n    if (sticky) {\n      const start = sticky.start || 0;\n      const end = sticky.end || start + 1;\n      layer.sticky = {\n        start,\n        end\n      };\n    }\n  });\n  React.useImperativeHandle(ref, () => layer);\n  const layerRef = useRef();\n  const setSticky = (height, scrollTop) => {\n    const start = layer.sticky.start * height;\n    const end = layer.sticky.end * height;\n    const isSticky = scrollTop >= start && scrollTop <= end;\n    if (isSticky === layer.isSticky) return;\n    layer.isSticky = isSticky;\n    const ref2 = layerRef.current;\n    ref2.style.position = isSticky ? \"sticky\" : \"absolute\";\n    ctrl.set({\n      translate: isSticky ? 0 : scrollTop < start ? start : end\n    });\n  };\n  useOnce(() => {\n    if (parent) {\n      parent.layers.add(layer);\n      parent.update();\n      return () => {\n        parent.layers.delete(layer);\n        parent.update();\n      };\n    }\n  });\n  const translate3d = ctrl.springs.translate.to(layer.horizontal ? x => `translate3d(${x}px,0,0)` : y => `translate3d(0,${y}px,0)`);\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: layerRef,\n    style: {\n      position: \"absolute\",\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      backgroundSize: \"auto\",\n      backgroundRepeat: \"no-repeat\",\n      willChange: \"transform\",\n      [layer.horizontal ? \"height\" : \"width\"]: \"100%\",\n      [layer.horizontal ? \"width\" : \"height\"]: ctrl.springs.space,\n      WebkitTransform: translate3d,\n      msTransform: translate3d,\n      transform: translate3d,\n      ...rest.style\n    }\n  });\n}));\nvar Parallax = React.memo(React.forwardRef((props, ref) => {\n  const [ready, setReady] = useState(false);\n  const {\n    pages,\n    innerStyle: _innerStyle,\n    config = configs.slow,\n    enabled = true,\n    horizontal = false,\n    children,\n    ...rest\n  } = props;\n  const containerRef = useRef();\n  const contentRef = useRef();\n  const state = useMemoOne(() => ({\n    config,\n    horizontal,\n    busy: false,\n    space: 0,\n    current: 0,\n    offset: 0,\n    controller: new Controller({\n      scroll: 0\n    }),\n    layers: /* @__PURE__ */new Set(),\n    container: containerRef,\n    content: contentRef,\n    update: () => update(),\n    scrollTo: offset => scrollTo(offset),\n    stop: () => state.controller.stop()\n  }), []);\n  useEffect(() => {\n    state.config = config;\n  }, [config]);\n  React.useImperativeHandle(ref, () => state);\n  const update = () => {\n    const container = containerRef.current;\n    if (!container) return;\n    const spaceProp = horizontal ? \"clientWidth\" : \"clientHeight\";\n    state.space = container[spaceProp];\n    const scrollType = getScrollType(horizontal);\n    if (enabled) {\n      state.current = container[scrollType];\n    } else {\n      container[scrollType] = state.current = state.offset * state.space;\n    }\n    const content = contentRef.current;\n    if (content) {\n      const sizeProp = horizontal ? \"width\" : \"height\";\n      content.style[sizeProp] = `${state.space * pages}px`;\n    }\n    state.layers.forEach(layer => {\n      layer.setHeight(state.space, true);\n      layer.setPosition(state.space, state.current, true);\n    });\n  };\n  const scrollTo = offset => {\n    const container = containerRef.current;\n    const scrollType = getScrollType(horizontal);\n    state.offset = offset;\n    state.controller.set({\n      scroll: state.current\n    });\n    state.controller.stop().start({\n      scroll: offset * state.space,\n      config,\n      onChange({\n        value: {\n          scroll\n        }\n      }) {\n        container[scrollType] = scroll;\n      }\n    });\n  };\n  const onScroll = event => {\n    if (!state.busy) {\n      state.busy = true;\n      state.current = event.target[getScrollType(horizontal)];\n      raf.onStart(() => {\n        state.layers.forEach(layer => layer.setPosition(state.space, state.current));\n        state.busy = false;\n      });\n    }\n  };\n  useEffect(() => state.update());\n  useOnce(() => {\n    setReady(true);\n    const onResize = () => {\n      const update2 = () => state.update();\n      raf.onFrame(update2);\n      setTimeout(update2, 150);\n    };\n    window.addEventListener(\"resize\", onResize, false);\n    return () => window.removeEventListener(\"resize\", onResize, false);\n  });\n  const overflow = enabled ? {\n    overflowY: horizontal ? \"hidden\" : \"scroll\",\n    overflowX: horizontal ? \"scroll\" : \"hidden\"\n  } : {\n    overflowY: \"hidden\",\n    overflowX: \"hidden\"\n  };\n  return /* @__PURE__ */React.createElement(a.div, {\n    ...rest,\n    ref: containerRef,\n    onScroll,\n    onWheel: enabled ? state.stop : void 0,\n    onTouchStart: enabled ? state.stop : void 0,\n    style: {\n      position: \"absolute\",\n      width: \"100%\",\n      height: \"100%\",\n      ...overflow,\n      WebkitOverflowScrolling: \"touch\",\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...rest.style\n    }\n  }, ready && /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(a.div, {\n    ref: contentRef,\n    style: {\n      overflow: \"hidden\",\n      position: \"absolute\",\n      [horizontal ? \"height\" : \"width\"]: \"100%\",\n      [horizontal ? \"width\" : \"height\"]: state.space * pages,\n      WebkitTransform: START_TRANSLATE,\n      msTransform: START_TRANSLATE,\n      transform: START_TRANSLATE_3D,\n      ...props.innerStyle\n    }\n  }, /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => !child.props.sticky && child))), /* @__PURE__ */React.createElement(ParentContext.Provider, {\n    value: state\n  }, mapChildrenRecursive(children, child => child.props.sticky && child))));\n}));\nexport { Parallax, ParallaxLayer };","map":null,"metadata":{},"sourceType":"module"}
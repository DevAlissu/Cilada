{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nconst isDragging = {\n  x: false,\n  y: false\n};\nfunction isDragActive() {\n  return isDragging.x || isDragging.y;\n}\nfunction resolveElements(elementOrSelector, scope, selectorCache) {\n  var _a;\n  if (elementOrSelector instanceof Element) {\n    return [elementOrSelector];\n  } else if (typeof elementOrSelector === \"string\") {\n    let root = document;\n    if (scope) {\n      // TODO: Refactor to utils package\n      // invariant(\n      //     Boolean(scope.current),\n      //     \"Scope provided, but no element detected.\"\n      // )\n      root = scope.current;\n    }\n    const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n    return elements ? Array.from(elements) : [];\n  }\n  return Array.from(elementOrSelector);\n}\nfunction setupGesture(elementOrSelector, options) {\n  const elements = resolveElements(elementOrSelector);\n  const gestureAbortController = new AbortController();\n  const eventOptions = {\n    passive: true,\n    ...options,\n    signal: gestureAbortController.signal\n  };\n  const cancel = () => gestureAbortController.abort();\n  return [elements, eventOptions, cancel];\n}\n\n/**\n * Filter out events that are not pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction filterEvents$1(callback) {\n  return event => {\n    if (event.pointerType === \"touch\" || isDragActive()) return;\n    callback(event);\n  };\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n  const onPointerEnter = filterEvents$1(enterEvent => {\n    const {\n      target\n    } = enterEvent;\n    const onHoverEnd = onHoverStart(enterEvent);\n    if (!onHoverEnd || !target) return;\n    const onPointerLeave = filterEvents$1(leaveEvent => {\n      onHoverEnd(leaveEvent);\n      target.removeEventListener(\"pointerleave\", onPointerLeave);\n    });\n    target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n  });\n  elements.forEach(element => {\n    element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n  });\n  return cancel;\n}\nconst isPrimaryPointer = event => {\n  if (event.pointerType === \"mouse\") {\n    return typeof event.button !== \"number\" || event.button <= 0;\n  } else {\n    /**\n     * isPrimary is true for all mice buttons, whereas every touch point\n     * is regarded as its own input. So subsequent concurrent touch points\n     * will be false.\n     *\n     * Specifically match against false here as incomplete versions of\n     * PointerEvents in very old browser might have it set as undefined.\n     */\n    return event.isPrimary !== false;\n  }\n};\nconst isPressing = new WeakSet();\n\n/**\n * Filter out events that are not \"Enter\" keys.\n */\nfunction filterEvents(callback) {\n  return event => {\n    if (event.key !== \"Enter\") return;\n    callback(event);\n  };\n}\nfunction firePointerEvent(target, type) {\n  target.dispatchEvent(new PointerEvent(\"pointer\" + type, {\n    isPrimary: true,\n    bubbles: true\n  }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n  const element = focusEvent.currentTarget;\n  if (!element) return;\n  const handleKeydown = filterEvents(() => {\n    if (isPressing.has(element)) return;\n    firePointerEvent(element, \"down\");\n    const handleKeyup = filterEvents(() => {\n      firePointerEvent(element, \"up\");\n    });\n    const handleBlur = () => firePointerEvent(element, \"cancel\");\n    element.addEventListener(\"keyup\", handleKeyup, eventOptions);\n    element.addEventListener(\"blur\", handleBlur, eventOptions);\n  });\n  element.addEventListener(\"keydown\", handleKeydown, eventOptions);\n  /**\n   * Add an event listener that fires on blur to remove the keydown events.\n   */\n  element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\n};\nconst focusableElements = new Set([\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"A\"]);\nfunction isElementKeyboardAccessible(element) {\n  return focusableElements.has(element.tagName) || element.tabIndex !== -1;\n}\n\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n  if (!child) {\n    return false;\n  } else if (parent === child) {\n    return true;\n  } else {\n    return isNodeOrChild(parent, child.parentElement);\n  }\n};\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n  return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\n *\n * This is different to a browser's `\"click\"` event, which does\n * respond to keyboards but only for the `\"click\"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart, options = {}) {\n  const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n  const startPress = startEvent => {\n    const element = startEvent.currentTarget;\n    if (!isValidPressEvent(startEvent) || isPressing.has(element)) return;\n    isPressing.add(element);\n    const onPressEnd = onPressStart(startEvent);\n    const onPointerEnd = (endEvent, success) => {\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerCancel);\n      if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n        return;\n      }\n      isPressing.delete(element);\n      if (onPressEnd) {\n        onPressEnd(endEvent, {\n          success\n        });\n      }\n    };\n    const onPointerUp = upEvent => {\n      onPointerEnd(upEvent, options.useGlobalTarget || isNodeOrChild(element, upEvent.target));\n    };\n    const onPointerCancel = cancelEvent => {\n      onPointerEnd(cancelEvent, false);\n    };\n    window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n    window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\n  };\n  elements.forEach(element => {\n    if (!isElementKeyboardAccessible(element)) {\n      element.tabIndex = 0;\n    }\n    const target = options.useGlobalTarget ? window : element;\n    target.addEventListener(\"pointerdown\", startPress, eventOptions);\n    element.addEventListener(\"focus\", event => enableKeyboardPress(event, eventOptions), eventOptions);\n  });\n  return cancelEvents;\n}\nfunction setDragLock(axis) {\n  if (axis === \"x\" || axis === \"y\") {\n    if (isDragging[axis]) {\n      return null;\n    } else {\n      isDragging[axis] = true;\n      return () => {\n        isDragging[axis] = false;\n      };\n    }\n  } else {\n    if (isDragging.x || isDragging.y) {\n      return null;\n    } else {\n      isDragging.x = isDragging.y = true;\n      return () => {\n        isDragging.x = isDragging.y = false;\n      };\n    }\n  }\n}\nexports.hover = hover;\nexports.isDragActive = isDragActive;\nexports.isDragging = isDragging;\nexports.isNodeOrChild = isNodeOrChild;\nexports.isPrimaryPointer = isPrimaryPointer;\nexports.press = press;\nexports.resolveElements = resolveElements;\nexports.setDragLock = setDragLock;","map":null,"metadata":{},"sourceType":"script"}